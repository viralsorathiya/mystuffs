$ErrorActionPreference = "Stop"

$region = '$(region)'

$dryRun = $true

# "Project Collection Build Service (tr-corp-tax)" user needs the "Manage releases" permission
function GetReleaseVariable([string]$name) {
    $connectionToken="${System.AccessToken}"
    $teamProject = $env:SYSTEM_TEAMPROJECT
    $orgUrl = $env:SYSTEM_COLLECTIONURI

    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Ssl3, [Net.SecurityProtocolType]::Tls, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls12

    $urlget = "$orgUrl/$teamProject/_apis/release/releases/$(Release.ReleaseId)?api-version=5.1"
    $base64AuthInfo = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes(":$($connectionToken)"))
    $getdef = Invoke-RestMethod -Headers @{Authorization=("Basic {0}" -f $base64AuthInfo)} -Method GET -ContentType application/json -Uri $urlget
    #Write-Host "Pipeline = $( $getdef | ConvertTo-Json -Depth 100)"

    $getdef.variables.PSObject.Properties[$name].Value.value
}

#$prodAMIs = GetReleaseVariable "prodAMIs_$(region)"
#if (-not $prodAMIs) {
# Write-Error "missing in-use prodAMI values"
#}

$preprodAMIs = GetReleaseVariable "preprodAMIs_$(region)"
if (-not $preprodAMIs) {
    Write-Error "missing in-use preprodAMIs values"
}

#Write-Host "prodAMIs = $prodAMIs"
Write-Host "preprodAMIs = $preprodAMIs"

Write-Host "populating imagesInUse for $region from variables"

$a = $prodAMIs -split ','
$b = $preprodAMIs -split ','
$images = ($a + $b) | & { $_ } | Select-Object -Unique
$imagesInUse = @{}
foreach ($i in $images) {
    $imagesInUse.Add($i, $i)
}

# GTM AMI Retention Logic
$gtmQuery = "Images[].{id:ImageId, CreationDate:CreationDate, Name:Name, ProdReady:Tags[?Key=='prod_ready']|[0].Value} | sort_by(@, &CreationDate) | reverse(@)"
$gtm_amis_str = (aws ec2 describe-images --region $region --owners self --filters `
    "Name=name,Values=ip-full-base-windows-ami-*", `
    "Name=tag:Name,Values=a205822*" `
    --query $gtmQuery) | Out-String

$gtm_amis = ConvertFrom-Json $gtm_amis_str

# Separate into prod_ready=True and missing-prod_ready
$gtmReadyAmis = $gtm_amis | Where-Object { $_.ProdReady -eq "True" }
$gtmPendingAmis = $gtm_amis | Where-Object { -not $_.PSObject.Properties.Name -contains "ProdReady" }

# Retain latest from each, safely
if ($gtmReadyAmis -and $gtmReadyAmis.Count -gt 0) {
    $latestGTMReady = $gtmReadyAmis[0]
    Write-Host "Retaining latest GTM AMI (prod_ready=True): $($latestGTMReady.id) $($latestGTMReady.Name)"
    $imagesInUse[$latestGTMReady.id] = $latestGTMReady.id
} else {
    Write-Host "No GTM AMI with prod_ready=True found."
}

if ($gtmPendingAmis -and $gtmPendingAmis.Count -gt 0) {
    $latestGTMPending = $gtmPendingAmis[0]
    Write-Host "Retaining latest GTM candidate AMI (no prod_ready tag): $($latestGTMPending.id) $($latestGTMPending.Name)"
    $imagesInUse[$latestGTMPending.id] = $latestGTMPending.id
} else {
    Write-Host "No GTM AMI found without prod_ready tag."
}

$MissingRelease = $false
$filterList = @(
    'Name=tag:ado:ReleaseName,Values="Release-* (release^*")',
    'Name=tag:ado:ReleaseName,Values="Release-* (develop^*")',
    'Name=tag:ado:ReleaseName,Values="Release-????"',
    'Name="name",Values="ip-full-base-windows-*"'
)

foreach ($filters in $filterList) {
    Write-Host "Filter: $filters"
    $dt = (Get-Date).AddDays(-15)
    if ($filters.Contains("develop")) {
        $dt = (Get-Date).AddDays(-3)
    }
    $createdDt = "{0:yyyy-MM-dd}" -f $dt
    $query = "Images[?CreationDate<'$createdDt'].{id:ImageId, CreationDate:CreationDate, Name:Name, ReleaseName:Tags[?Key=='ado:ReleaseName']|[0].Value, ReleaseURL:Tags[?Key=='ado:WebURL']|[0].Value}[] | sort_by(@, &CreationDate)"

    if ($MissingRelease) {
        $amis_str = (aws ec2 describe-images --region $region --owners self --query $query) | Out-String
        $amis = ConvertFrom-Json $amis_str | Where-Object { $_.ReleaseName -eq $null }
    } else {
        $amis_str = (aws ec2 describe-images --region $region --owners self --filters $filters --query $query) | Out-String
        $amis = ConvertFrom-Json $amis_str
    }

    $totalCount = ($amis | Measure-Object).Count
    Write-Host "found $totalCount amis matching filter"

    if ($totalCount -le 1) {
        Write-Host "Skipping deletion. Only 1 or fewer AMIs found."
        continue
    }

    $amis = $amis | Sort-Object { [datetime]$_.CreationDate } -Descending
    $retainId = $amis[0].id
    Write-Host "Retaining latest AMI: $retainId $($amis[0].Name)"
    $imagesInUse.Add($retainId, $retainId)

    foreach ($ami in $amis[1..($amis.Count - 1)]) {
        if ($imagesInUse.ContainsKey($ami.id)) {
            Write-Warning "Skipping in-use AMI: $($ami.id) $($ami.Name)"
        } else {
            if ($dryRun) {
                Write-Host "[DryRun] Would delete AMI: $($ami.id) $($ami.Name)"
            } else {
                Write-Host "Deleting AMI: $($ami.id) $($ami.Name)"
                aws ec2 deregister-image --region $region --image-id $ami.id
            }
        }
    }
}
